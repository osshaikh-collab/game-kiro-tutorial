Building a 2D Game with AI: A Prompting GuideClean Chat Log with CommentaryThis document showcases effective prompting techniques used to build a complete 2D platformer game from scratch. Pay attention to how the student communicates clearly, tests iteratively, and refines requests.Phase 1: Getting StartedStudent: You are a computer science teacher and I am a student new to coding. I am thinking of using you to build a simple 2D game - a recreation of Mario 1985. You already suggested getting started with phase 1, game loop and created the html and js files in this project. Let us pick up where we left off in the lesson.AI: Perfect! I can see we've got Phase 1 up and running - you have a basic game loop with a player (the red square) that can move left/right and jump. The fundamentals are solid.What you've accomplished:A game loop using requestAnimationFrame (runs ~60 times per second)Player movement with arrow keysJumping with spacebarGravity and ground collision detectionPhase 2 Options: Add platforms, enemies, better visuals, or level scrolling. Which sounds most interesting?ðŸ’¡ Prompting Tip: Setting clear roles ("you are a teacher, I am a student") helps calibrate the AI's response style and detail level.Student: Before we move to phase 2, I'm curious about making mario look like mario. Are you going to download a public sprite from the internet? Or will you recreate mario bit by bit? If the latter, how would I even do that without AI assistance?AI: Great question! Here are your realistic options:Use existing sprite sheets - Standard approach for indie developersDraw pixel art manually - Use tools like Piskel or Aseprite, clicking pixel by pixelDraw with code - I can create a simplified Mario using canvas drawing commandsFor learning purposes, I recommend Option 3 - I'll create a "Mario-inspired" character using code that's 100% yours.ðŸ’¡ Prompting Tip: Asking "how would I do this without AI?" demonstrates curiosity and deepens understanding of the underlying concepts.Student: Before moving to phase 2, how do I test phase 1? Can I run this locally on my laptop?AI: Absolutely! Just double-click the game.html file in your file explorer. It should open in your browser and work immediately.You should see:Blue background (sky)Brown ground at the bottomRed square (Mario) you can control with arrow keys and spacebarðŸ’¡ Prompting Tip: Testing before moving forward is professional practice. Validate each phase to prevent compounding errors.Student: It works! Let's move to phase 2.ðŸ’¡ Prompting Tip: Confirming success before proceeding keeps development on track and builds confidence.Phase 2: Adding PlatformsAI: Let's add platforms - blocks that Mario can jump on and stand on. I'll create collision detection so Mario can land on platforms without falling through them.[AI implements platform array and collision detection]Student: My "mario" is falling through platforms. Can you debug and edit the file?AI: I see the issue! The collision detection was checking position AFTER the player moved. Let me fix this by tracking the old Y position before movement.[AI fixes the collision detection logic]ðŸ’¡ Prompting Tip: Clear bug reports ("falling through platforms") with observable behavior help the AI quickly identify and fix issues.Student: It works! Let's go to phase 3.Phase 3: Adding EnemiesAI: Let's add a simple enemy that moves back and forth. We'll create a Goomba-like enemy that patrols on a platform with collision detection.[AI implements enemy with patrol behavior and game over on collision]Student: It works! Let's do all of those items in phase 4.[Referring to: jump on enemies to defeat them, multiple enemies, collectible coins, lives system]ðŸ’¡ Prompting Tip: After successful iterations, confidently requesting multiple features accelerates development while maintaining quality.Phase 4: Game Mechanics[AI implements stomping enemies, 3 enemies on different platforms, 5 collectible coins, 3-lives system, scoring]Student: I want to test your sprite animation capabilities. Instead of making the red box look like Mario, make a generic golden retriever puppy in the old NES era sprite style.AI: Fun challenge! I'll create a golden retriever puppy in authentic NES pixel art style using canvas drawing commands - 8x8 pixel grid with limited color palette.[AI creates pixel-by-pixel puppy sprite with golden fur, floppy ears, black eyes/nose, pink tongue]ðŸ’¡ Prompting Tip: Adding creative constraints ("NES era sprite style," specific subject) tests capabilities while making the project unique and personal.Phase 5: Polish and Extended LevelStudent: Looks good! Let's move to phase 5.AI: Let's add camera scrolling, a longer level, a goal/finish line, and restart functionality.[AI implements 3x wider level, camera following, 8 additional platforms, 3 more enemies, 7 more coins, green finish line, press 'R' to restart]Phase 6: Sound Effects and Power-UpsStudent: Yes, let's add sound effects for jumping, killing an enemy, game over, and winning. Also let's add blocks that reveal power ups just like in mario. Instead of a red mushroom, the powerup should be a dog treat. The power up does not make the player grow, instead jump distance is increased by 1.5x and message will display that says "super jump unlocked!"ðŸ’¡ Prompting Tip: Using references ("just like in mario") provides a shared mental model. The AI understands the desired behavior without lengthy explanations.[AI implements Web Audio API sounds and power-up block system with dog treats]Refinement Phase: Bug Fixes and ImprovementsStudent: When an enemy walks into the player, there is no game over screen. A horizontal collision should result in game over. Also the power up blocks should be solid, meaning jumping from under the block should cause the player to stop moving up. Change the positioning of the first 2 power up blocks to be higher off the platform. When the block is hit, the power up dog treat should slowly emerge from the top of the block and fall to either side randomly like in Mario for NES.ðŸ’¡ Prompting Tip: Comprehensive feedback in one message is more efficient than multiple back-and-forth exchanges. List all issues and requirements together.[AI fixes enemy collision, makes blocks solid, repositions blocks, adds Mario-style treat emergence animation]Student: Move the third block either lower or higher so it is not overlapping with the platform. Make the super jump condition last only 5 seconds and play a sound to indicate when the condition is over.[AI repositions block and adds 5-second timer with countdown and end sound]Student: Block 3 is still too close to the platform. Move 150 pixels lower.ðŸ’¡ Prompting Tip: Specific, measurable requests ("150 pixels lower") eliminate ambiguity and get exactly what you want. Avoid vague requests like "fix it."[AI moves block precisely 150 pixels]Final Features: Timer and ScoringStudent: Add a feature where each remaining life adds 500 points. Add a 60 second timer - if the timer runs to 0, trigger game over. On winning, each remaining second adds 100 points. On the you win screen, give the player a breakdown of the source of their points (show number of coins collected, enemy kills, etc.)ðŸ’¡ Prompting Tip: Clear, structured requirements with specific values (500 points per life, 60 seconds, 100 points per second) ensure accurate implementation.[AI implements 60-second countdown timer, bonus point system, detailed score breakdown screen]DeploymentStudent: I want to share this game with my coworkers and I also want to share our chatlog to show best practices in prompting. How do I do that?AI: For the game, you can zip and email the files, host on GitHub Pages, or use free hosting like Netlify. For the chat log, look for export options in Kiro's menu.Student: Yes [create a README].[AI creates comprehensive README.md with game overview, controls, setup instructions]Student: I uploaded to a github repo and deployed to pages but the page only shows the readme file and not the actual game.AI: GitHub Pages looks for index.html by default. Let me rename game.html to index.html for you.ðŸ’¡ Prompting Tip: When stuck, clearly describe what you expected vs. what happened. This helps the AI diagnose the issue quickly.Key TakeawaysEffective Prompting Patterns Used:Role Setting - Established teacher/student relationship upfrontPhase-Gate Development - Test after each phase before proceedingCuriosity Questions - Asked "how" and "why" to deepen understandingSpecific Measurements - Used precise values (150 pixels, 5 seconds, 500 points)Reference Models - Used "like in Mario" to communicate complex behaviorsComprehensive Feedback - Listed multiple issues in single messagesClear Bug Reports - Described observable problems conciselyValidation Loops - Confirmed "it works!" before moving forwardProject Results:âœ… Complete 2D platformer game built from scratchâœ… 6 development phases completed successfullyâœ… ~500 lines of functional JavaScript codeâœ… 12+ features implemented (collision, enemies, power-ups, scoring, timer, etc.)âœ… Deployed to GitHub Pages and shareable with othersâœ… Full documentation createdTime Investment: ~90 minutes of active prompting
Learning Outcome: Progressed from "new to coding" to understanding game loops, collision detection, state management, and deploymentThis chat log demonstrates that effective AI collaboration requires clear communication, iterative testing, specific feedback, and genuine curiosity. The student treated the AI as a collaborative partner, which led to both a successful project and real learning.